# 関数型プログラミングの基礎

## 1 章

読んだけど省略

## 2 章

### なぜ関数型プログラミングが重要か

**数学の関数は「ある値に対して、ただ一つの値が対応するような関係」**
関数は 1 つの入力に対して 1 つの出力。
自販機に例えられる。 引数・入力(硬貨)と出力・戻り値（飲み物）

**入力が同じならいつどこで呼び出されても値は一定**
三角関数の cos(θ)はいつどこで呼び出しても値は 1
入力 0 に対しての出力はいつも 1

**プログラミングが数学的な関数と異なる点**
・計算を具体的な「手順」として定義しなければならない。
手順とは計算が完了するための有限のステップ。　
このような制限を設けた手順のことをアルゴリズムと呼ぶ。
・関数によっては同じ因数に対していつも同じ結果を返すわけではない。
例えば現在の時刻を求める関数は呼び出されるたびに
前回とは異なる結果を返す。

### 関数型プログラミングの特徴

関数型モデルを実装したプログラミング言語を関数型言語という。
JavaScript は関数型言語と命令形言語の機能を持つ。

これらの条件を満たせば関数型プログラミングは可能。

**関数を言語の最も基本的な要素として扱う**
関数に値としての地位を与えることで関数に関数を渡したり、
関数から返すことが可能になる。
**参照透過性を確保できること**

> [!NOTE]
> 参照透過性とは、プログラムの構成要素が同じであれば同じ結果を返す性質を指す。

## ファーストクラスオブジェクトとしての関数

関数型プログラミングを可能にする第一の性質は
**ファーストクラスオブジェクト(first-class citizen)** としての関数。
ファーストクラスオブジェクトとは計算の対象となる「値」を意味する。
ファーストクラスオブジェクトとしての値は次のように変数にバインドしたり、データ構造に埋め込んだり関数に渡したり、関数の返値とすることが可能である。

```bash
> var zero = 0; # 変数に値をバインド
undefined
> var birthday = { # データ構造に値を埋め込む
... year: 1999,
... month: 1,
... day: 12
... }
undefined
> Math.sqrt(2) # 関数に値を渡す
1.4142135623730951 # 関数から値を返す
```

関数がファーストクラスオブジェクトであるということは、関数も次のような操作が可能。

1. 関数を変数にバインドする
2. 関数をデータ構造に埋め込む
3. 関数適用の際に関数を引数として渡す
4. 関数から関数を返す。

### 関数は変数にバインドすることができる。
元々関数定義(λ式 :ラムダ式)そのものには名前はない。 -> 無名関数

ラムダ式として変数にバインドすることで無名関数に名前をつける。

```javascript
var succ = (n) => { // var succ = 以降がラムダ式
	return n+ 1;
}
```
### 関数はデータ構造に埋め込むことが埋め込むことができる

関数はデータ構造に埋め込むことができる

複数の関数を同じオブジェクトで埋め込むことによって似通った機能を持つ関数を一箇所にまとめることができる。

```javascript
var math =
add: (n, m) => {
	return n + m;
};
```
関数がファーストクラスオブジェクトであることの最大の利点は**高階関数**の利用が可能になること。
**高階関数(higher-order function)** とは関数を引数として受け取ったり関数を返すことができる関数。
高階関数ではある関数の引数に別の関数を渡すことができる。　この手法を「**関数渡し**」と呼ぶ。

下記はforEachメソッド。
関数を受け取り配列の要素ごとにその渡された関数を実行する高階関数。

```javascript
var sum = (array) => {
	var result = 0;
	array.forEach((item) => {
		result += item;
	})
	return result;
}
```
forEachのメソッドの引数は(item) => { ... } という関数になっている。
この部分が関数渡し。
この関数が呼び出される時にitemに個々の要素が入る。
arrayが[1,3,5]の場合、 0 + 1, 1 + 3, 4 + 5が計算される。

高階関数は関数を返すこともできる。この一例として**カリー化**がある。
下記は足し算を定義するadder関数をカリー化により定義したもの。

```javascript
var adder = (n) => {
	return (m) => { return n + m; }; // 無名関数を返す
};
```
これはnというただ一つの引数を受け取ると`(m) => { return n + m; };`という無名関数を返す。
adder(1) だと`(m) => { return n + m; };`が返ってくる。 adder(1)(2)だと無名関数に2が渡されて3が返る。
カリー化関数は関数が関数を返すという性質により成り立つ。

## 参照透過性
関数型プログラミングに必要な第二の性質は参照透過性。 参照透過性とは、簡単に言うと「プログラミングの構成要素が同じもの同士は等しい」という性質。
`A === A`

プログラミングでは必ずしも参照透過性が担保されているとは限らない。

### 値の参照透過性

`2 === 2`は必ず真になる。
```javascript
> 2 === 2
true
```
javascriptの数値にはいつも参照透過性が保たれているが、配列やオブジェクトなどの合成型は参照透過性を持たない。

### 変数の参照透過性
`x === x`にも参照透過性が成立しているか。

```javascript
> var x = 1
undefined
> x === x;
true
```
`x === x`の等式が成立していることから参照透過性が成立している。
が、変数の参照透過性もあらゆる場面で保証されているわけではない。
代入という操作が加わると変数の参照透過性は破壊される。

### 関数の参照透過性

関数が参照透過性を持つためのルールはある関数への引数が同じであればその関数は必ず同じ値を返さなければならない。

1を渡すと必ず2を返すsucc関数があるとする。
```javascript
> succ(1) === succ(1)
> true
```

ただしあらゆる関数が参照透過性を保証されているわけではなく、ある種の関数には参照透過性がない。(副作用)

### 参照透過性を破壊するもの

値の中には一旦作成されたあとに内容が変更されるデータ構造がある。
内容が変更される可能性のあるデータは**可変データ**と呼ばれる。
このようなデータに参照透過性はない。

JavaScriptの配列は可変なデータ構造の一つ。

```JavaScript
> var array = [1]
undefined
> array
[ 1 ]
> array.push(2)
2
> array
[ 1, 2 ]
```

この例では配列の値を2回確かめているが結果がそれぞれ異なる。
pushのようにデータの中身を変更するメソッドを**破壊的メソッド**と呼ぶ。

#### 代入は参照透過性を破壊する
変数の参照透過性は代入という操作で簡単に破壊される。
「代入」とは変数に何らかの値を割り当てる操作。
`var x = 0; // この操作が代入`

変数の参照透過性は代入という操作で簡単に破壊される。

コードの隠れた存在をコードにとってのコンテキストと呼ぶ。

> ![NOTE]
> コンテキストは日本語で「文脈」を指す。
> 例えば8月は暑いという文章にも隠れた状態が潜んでおり、
> それは場所というコンテキストである。
> 南半球の8月は真冬　文章だけでは正しさは判断できない。

代入は参照透過性の喪失という厄介な効果をもたらし、関数型プログラミングを困難にする。
その代入という仕組みを多くの言語が準備しているかというと、whileなどの反復文を利用するのに不可欠だから。

階乗は下記のようにwhile文で表す。

```javascript
var factorial = (n) => {
	var result = 1; // 結果を格納する
	var times = 1; // 反復の回数を数える
	while (times < n + 1) {
		// result を代入で更新する
		result = result * times;
		// timesを代入で更新する
		times = times + 1;
	}
	return result;
}
```

#### 副作用と入出力
ある種の関数にはもともと参照透過でない関数がある。
DataメソッドやRandメソッドなど。

入出力を扱う関数にも参照透過性はない。
ここでの入出力はプログラミングの処理系へのデータの入出力を指す。
画面の出力やファイルへの書き込み処理や、キーボードによる入力やファイルからの読み出しなど。

このような副次的な機能は**副作用**と呼ぶ。

入出力は処理系にとって隠れたコンテキスト。

## 参照透過性を保証する
まとめると参照透過性は次のような場面で喪失する。

- 値の参照透過性を破壊する可変なデータ
- 変数の参照透過性を破壊する代入操作
- 関数の参照透過性を破壊する副作用

本項ではこうした状況を回避してコードの参照透過性を探る。

### 値の参照透過性を保証する(可変なデータの排除)
一度生成されたら中身が変更されないデータのことを**不変のデータ**と呼ぶ。
値の参照透過性を確保するにはすべてのデータを不変のデータとして構築すれば良い。

JavaScriptにおける可変のデータとは配列やオブジェクト型のことを指す。
このような可変なデータを不変なデータ構造として構築するには関数を用いる。

```javascript
// これは空のオブジェクトを表現する関数です。
// どんな引数（_で表現）が渡されても常にnullを返します。
var empty = (_) => {
	return null;
}
// この関数は、キーとオブジェクトを引数に取り、オブジェクトに対してキーを適用した結果を返します。
// ここでの「オブジェクト」は実際には関数として扱われています。
var get = (key, obj) => {
	return obj(key);
};
// この関数は新しい値をオブジェクトに「設定」します。具体的には：
// 新しいキー、値、既存のオブジェクトを引数に取ります。
// 新しい関数を返します。この関数は：
// 渡されたキー（key2）が設定しようとしたキー（key）と同じ場合、新しい値を返します。
// そうでない場合、元のオブジェクトから値を取得します。
var set = (key, value, obj) => {
	return (key2) => {
		if(key === key2) {
			return value;
		} else {
			return get(key2, obj);
		}
	};
};
```
```javascript
// まず、空のオブジェクトから始めます
let obj = empty;

// 値をセットします
obj = set('name', 'Alice', obj);
obj = set('age', 30, obj);

// 値を取得します
console.log(get('name', obj)); // 'Alice' を出力
console.log(get('age', obj));  // 30 を出力

// 存在しないキーにアクセスすると
console.log(get('city', obj)); // null を出力

// 値を更新します
obj = set('age', 31, obj);
console.log(get('age', obj));  // 31 を出力

// 元の 'age' の値は変更されていないことを確認
let oldObj = set('name', 'Alice', empty);
oldObj = set('age', 30, oldObj);
console.log(get('age', oldObj)); // 30 を出力
```