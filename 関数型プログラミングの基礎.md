# 関数型プログラミングの基礎

## 1 章

読んだけど省略

## 2 章

### なぜ関数型プログラミングが重要か

**数学の関数は「ある値に対して、ただ一つの値が対応するような関係」**
関数は 1 つの入力に対して 1 つの出力。
自販機に例えられる。 引数・入力(硬貨)と出力・戻り値（飲み物）

**入力が同じならいつどこで呼び出されても値は一定**
三角関数の cos(θ)はいつどこで呼び出しても値は 1
入力 0 に対しての出力はいつも 1

**プログラミングが数学的な関数と異なる点**
・計算を具体的な「手順」として定義しなければならない。
手順とは計算が完了するための有限のステップ。
このような制限を設けた手順のことをアルゴリズムと呼ぶ。
・関数によっては同じ因数に対していつも同じ結果を返すわけではない。
例えば現在の時刻を求める関数は呼び出されるたびに
前回とは異なる結果を返す。

### 関数型プログラミングの特徴

関数型モデルを実装したプログラミング言語を関数型言語という。
JavaScript は関数型言語と命令形言語の機能を持つ。

これらの条件を満たせば関数型プログラミングは可能。

**関数を言語の最も基本的な要素として扱う**
関数に値としての地位を与えることで関数に関数を渡したり、
関数から返すことが可能になる。
**参照透過性を確保できること**

> [!NOTE]
> 参照透過性とは、プログラムの構成要素が同じであれば同じ結果を返す性質を指す。

## ファーストクラスオブジェクトとしての関数

関数型プログラミングを可能にする第一の性質は
**ファーストクラスオブジェクト(first-class citizen)** としての関数。
ファーストクラスオブジェクトとは計算の対象となる「値」を意味する。
ファーストクラスオブジェクトとしての値は次のように変数にバインドしたり、データ構造に埋め込んだり関数に渡したり、関数の返値とすることが可能である。

```bash
> var zero = 0; # 変数に値をバインド
undefined
> var birthday = { # データ構造に値を埋め込む
... year: 1999,
... month: 1,
... day: 12
... }
undefined
> Math.sqrt(2) # 関数に値を渡す
1.4142135623730951 # 関数から値を返す
```

関数がファーストクラスオブジェクトであるということは、関数も次のような操作が可能。

1. 関数を変数にバインドする
2. 関数をデータ構造に埋め込む
3. 関数適用の際に関数を引数として渡す
4. 関数から関数を返す。

### 関数は変数にバインドすることができる

元々関数定義(λ式 :ラムダ式)そのものには名前はない。 -> 無名関数

ラムダ式として変数にバインドすることで無名関数に名前をつける。

```javascript
var succ = (n) => { // var succ = 以降がラムダ式
 return n+ 1;
}
```

### 関数はデータ構造に埋め込むことが埋め込むことができる

関数はデータ構造に埋め込むことができる

複数の関数を同じオブジェクトで埋め込むことによって似通った機能を持つ関数を一箇所にまとめることができる。

```javascript
var math =
add: (n, m) => {
 return n + m;
};
```

関数がファーストクラスオブジェクトであることの最大の利点は**高階関数**の利用が可能になること。
**高階関数(higher-order function)** とは関数を引数として受け取ったり関数を返すことができる関数。
高階関数ではある関数の引数に別の関数を渡すことができる。　この手法を「**関数渡し**」と呼ぶ。

下記はforEachメソッド。
関数を受け取り配列の要素ごとにその渡された関数を実行する高階関数。

```javascript
var sum = (array) => {
 var result = 0;
 array.forEach((item) => {
  result += item;
 })
 return result;
}
```

forEachのメソッドの引数は(item) => { ... } という関数になっている。
この部分が関数渡し。
この関数が呼び出される時にitemに個々の要素が入る。
arrayが[1,3,5]の場合、 0 + 1, 1 + 3, 4 + 5が計算される。

高階関数は関数を返すこともできる。この一例として**カリー化**がある。
下記は足し算を定義するadder関数をカリー化により定義したもの。

```javascript
var adder = (n) => {
 return (m) => { return n + m; }; // 無名関数を返す
};
```

これはnというただ一つの引数を受け取ると`(m) => { return n + m; };`という無名関数を返す。
adder(1) だと`(m) => { return n + m; };`が返ってくる。 adder(1)(2)だと無名関数に2が渡されて3が返る。
カリー化関数は関数が関数を返すという性質により成り立つ。

## 参照透過性

関数型プログラミングに必要な第二の性質は参照透過性。 参照透過性とは、簡単に言うと「プログラミングの構成要素が同じもの同士は等しい」という性質。
`A === A`

プログラミングでは必ずしも参照透過性が担保されているとは限らない。

### 値の参照透過性

`2 === 2`は必ず真になる。

```javascript
> 2 === 2
true
```

javascriptの数値にはいつも参照透過性が保たれているが、配列やオブジェクトなどの合成型は参照透過性を持たない。

### 変数の参照透過性

`x === x`にも参照透過性が成立しているか。

```javascript
> var x = 1
undefined
> x === x;
true
```

`x === x`の等式が成立していることから参照透過性が成立している。
が、変数の参照透過性もあらゆる場面で保証されているわけではない。
代入という操作が加わると変数の参照透過性は破壊される。

### 関数の参照透過性

関数が参照透過性を持つためのルールはある関数への引数が同じであればその関数は必ず同じ値を返さなければならない。

1を渡すと必ず2を返すsucc関数があるとする。

```javascript
> succ(1) === succ(1)
> true
```

ただしあらゆる関数が参照透過性を保証されているわけではなく、ある種の関数には参照透過性がない。(副作用)

### 参照透過性を破壊するもの

値の中には一旦作成されたあとに内容が変更されるデータ構造がある。
内容が変更される可能性のあるデータは**可変データ**と呼ばれる。
このようなデータに参照透過性はない。

JavaScriptの配列は可変なデータ構造の一つ。

```JavaScript
> var array = [1]
undefined
> array
[ 1 ]
> array.push(2)
2
> array
[ 1, 2 ]
```

この例では配列の値を2回確かめているが結果がそれぞれ異なる。
pushのようにデータの中身を変更するメソッドを**破壊的メソッド**と呼ぶ。

#### 代入は参照透過性を破壊する

変数の参照透過性は代入という操作で簡単に破壊される。
「代入」とは変数に何らかの値を割り当てる操作。
`var x = 0; // この操作が代入`

変数の参照透過性は代入という操作で簡単に破壊される。

コードの隠れた存在をコードにとってのコンテキストと呼ぶ。

> ![NOTE]
> コンテキストは日本語で「文脈」を指す。
> 例えば8月は暑いという文章にも隠れた状態が潜んでおり、
> それは場所というコンテキストである。
> 南半球の8月は真冬　文章だけでは正しさは判断できない。

代入は参照透過性の喪失という厄介な効果をもたらし、関数型プログラミングを困難にする。
その代入という仕組みを多くの言語が準備しているかというと、whileなどの反復文を利用するのに不可欠だから。

階乗は下記のようにwhile文で表す。

```javascript
var factorial = (n) => {
 var result = 1; // 結果を格納する
 var times = 1; // 反復の回数を数える
 while (times < n + 1) {
  // result を代入で更新する
  result = result * times;
  // timesを代入で更新する
  times = times + 1;
 }
 return result;
}
```

#### 副作用と入出力

ある種の関数にはもともと参照透過でない関数がある。
DataメソッドやRandメソッドなど。

入出力を扱う関数にも参照透過性はない。
ここでの入出力はプログラミングの処理系へのデータの入出力を指す。
画面の出力やファイルへの書き込み処理や、キーボードによる入力やファイルからの読み出しなど。

このような副次的な機能は**副作用**と呼ぶ。

入出力は処理系にとって隠れたコンテキスト。

## 参照透過性を保証する

まとめると参照透過性は次のような場面で喪失する。

- 値の参照透過性を破壊する可変なデータ
- 変数の参照透過性を破壊する代入操作
- 関数の参照透過性を破壊する副作用

本項ではこうした状況を回避してコードの参照透過性を探る。

### 値の参照透過性を保証する(可変なデータの排除)

一度生成されたら中身が変更されないデータのことを**不変のデータ**と呼ぶ。
値の参照透過性を確保するにはすべてのデータを不変のデータとして構築すれば良い。

JavaScriptにおける可変のデータとは配列やオブジェクト型のことを指す。
このような可変なデータを不変なデータ構造として構築するには関数を用いる。

```javascript
// これは空のオブジェクトを表現する関数です。
// どんな引数（_で表現）が渡されても常にnullを返します。
var empty = (_) => {
 return null;
}
// この関数は、キーとオブジェクトを引数に取り、オブジェクトに対してキーを適用した結果を返します。
// ここでの「オブジェクト」は実際には関数として扱われています。
var get = (key, obj) => {
 return obj(key);
};
// この関数は新しい値をオブジェクトに「設定」します。具体的には：
// 新しいキー、値、既存のオブジェクトを引数に取ります。
// 新しい関数を返します。この関数は：
// 渡されたキー（key2）が設定しようとしたキー（key）と同じ場合、新しい値を返します。
// そうでない場合、元のオブジェクトから値を取得します。
var set = (key, value, obj) => {
 return (key2) => {
  if(key === key2) {
   return value;
  } else {
   return get(key2, obj);
  }
 };
};
```

```javascript
// まず、空のオブジェクトから始めます
let obj = empty;

// 値をセットします
obj = set('name', 'Alice', obj);
obj = set('age', 30, obj);

// 値を取得します
console.log(get('name', obj)); // 'Alice' を出力
console.log(get('age', obj));  // 30 を出力

// 存在しないキーにアクセスすると
console.log(get('city', obj)); // null を出力

// 値を更新します
obj = set('age', 31, obj);
console.log(get('age', obj));  // 31 を出力

// 元の 'age' の値は変更されていないことを確認
let oldObj = set('name', 'Alice', empty);
oldObj = set('age', 30, oldObj);
console.log(get('age', oldObj)); // 30 を出力
```

次に変数の参照透過性を保証する(代入の排除)
変数の参照透過性を保証するには代入を使わない。

多くの場合、代入を使わなくてもプログラミングは可能だが、反復処理はその限りではない。

```javascript
var add = (x, y) => {
 var times = 0;
 var result = x;

 while(times < y) {
  result = result + 1;
  times = times + 1;
 };
 return result;
};
```

関数型プログラミングの手法を使えば、代入無しで反復処理を実現できる。

```javascript
var add = (x, y) => {
 if(y < 1) {
  return x;
 } else {
  return add(x + 1, y - 1);
 }
};

console.log(add(3, 2));  // 出力: 5
console.log(add(0, 5));  // 出力: 5
console.log(add(10, 0)); // 出力: 10
console.log(add(1, 9));  // 出力: 10
console.log(add(-3, 7)); // 出力: 4
```

```
// 流れ
add(3, 2)　->
1回目 y<1なので 4,1を返す
2回目 y<1なので 5,0を返す
3回目 y<1じゃないので 5,0を返す
出力が5になる
```

関数型プログラミングによる実装では、反復を実行するwhile文を使わずに、同じ関数を呼び出す再起処理で反復を実現しいる。
代入がないがかわりに関数が再帰的に呼び出されるたびに新しい引数を渡している。

### 値の参照透過性を保証する(副作用の分離)

副作用をなくしてしまえば問題が解決するわけではない。
というのは計算機には計算結果を表示する機能やデータを記録する装置が不可欠だから。

では、関数型プログラミングではこの副作用をどのように扱うのかというと、副作用を持つ方法と副作用を持たない部分をきちんと分離する。

副作用を持たない関数を**純粋な関数**と呼ぶ。

副作用を持つ関数は純粋な関数を呼び出せるが、逆に純粋な関数から副作用を持つ関数を呼び出してはいけない。

下記は副作用が分離されていないコード

```javascript
var age = (birthYear) => {
 // todayは現時点の日付
 var today = new Date();
 // getFullYear関数は日付データに基づいて現時点の西暦を返す
 var thisYear = today.getFullYear();
 return thisYear - birthYear;
};
```

2016年時点だと17を返すが、2017年だと18という異なる値を返す。
var today = new Date();というコンテキストに依存しており、この依存がage関数から分離されていない。

内部に副作用を持つ関数は関数自体が参照透過性を失ってしまう。

age関数に参照透過性を持たせるには現在の時刻というコンテキストを外部に出す必要がある。

```javascript
var age = (birthYear, thisYear) => {
 return thisYear - birthYear;
};
```

上記のコードでは隠れていたコンテキストを関数の引数として明示的に渡すことで参照透過性を取り戻している。
そのため、age(1999, 2016)というコードはいつに時代になっても必ず17を返すことになる。
現時点での年齢を求めたい場合には、age(1999,(new Date()).getFullYear())とする。

副作用を分離するためのより柔軟な方法はモナド。
モナドは高階関数を使ってコンテキストをカプセル化する。

特に副作用の根源である入出力をカプレス化すると、副作用を持つ関数を組み合わせてより複雑な入出力を作り上げることが可能になる。

## 関数型プログラミングの利点

そもそもなんで関数型プログラミングが望ましい？
関数型プログラミングは修行僧ではなく、アスリート。

自らのコードをコントロールすることで次のような利点を手にすることができる。

- コードのモジュール性が高まる
- コードのテストを容易にする
- コードの正しさを証明できる

### 高いモジュール性

関数型プログラミングの利点として第一に挙げられるのは**モジュール性**。
ソフトウェアに色々な機能を追加するとすぐに巨大に膨れ上がる。
そうした自体に対する対処方法は全体を小さな単位に分割すること。

問題をモジュールに分解することをモジュール化と呼ぶ。

モジュール化によるプログラミングは次のような手順で問題を解決する。

1. 大きな問題を小さな問題に分割する
2. 小さな部品で小さな問題を解く
3. 小さな問題を解く小さな部品を組み合わせて大きな問題を解く

モジュール化の戦略はレゴブロックで作品を組み上げていく作業に似ている。
データ,変数,関数がブロック ブロック同士をつなぎ合わせるのは関数。

### 部品の独立性

モジュール化に必要な第一の性質はここのモジュールの機能が独立していること。
コードがモジュールとして独立していると他のコードが影響を受けにくくなる。
参照透過性はこの独立性を保証する。

### 部品の汎用性

モジュール化を成功させるためにはやみくもに独立した部品を作れば良いというわけではない。
モジュール化に必要な第二の性質は部品の汎用性。
汎用性とは「どこでも使うことができる」という性質。
レゴブロックは汎用性が高いがパズルのピースは汎用性が低い。
レゴブロックを目指す。

レゴブロックの凹凸に相当するのが引数で、関数に汎用性をもたせる一つの方法がカリー化。
カリー化により引数の個数を1個にすれば引数の数を一致させる必要がない。

関数の汎用性を高めるもう一つの方法が**関数渡し**。
関数渡しもカリー化同様、高階関数が可能にした関数型プログラミングの技法。

関数渡しの代表的な例はJavaScriptの配列に備わっているreduceメソッド。
reduceメソッドの引数を返ることで様々な関数を生み出すことができる。
forEachメソッドとreduceメソッドのsum関数を比較する。

```javascript
// forEachメソッドによるsum関数の定義
var sum = (array) => {
 var result = 0;
 var index = 0; // 反復回数を格納する
 while(index < array.length) {
  result = result + array[index];
  index = index + 1;
 }
 return result;
}

// reduceメソッドによるsum関数の定義
var sum = (array) => {
 return array.reduce(
  (accumulator, item) => {
   return accumulator + item;
  }, 0); // 代二引数に初期値として0を渡す。
};
// 配列が[1,2,3]の場合の動作
// 0 + 1 [2,3]
// 1 + 2 [3]
// 3 + 3
// 6
```

accumulator 蓄圧器の意味 アキュムレーター
reduceメソッドが起動した際、無名関数`(accumulator, item ) => { ... }`がreduceメソッドに渡される。
この関数ではaccumulatorには初期値の0、引数itemを計算し、その結果である1を次のaccumulatorとして渡す。
計算された値はaccumulatorに蓄積される。　配列に要素が無くなると、reduceメソッドはそれまでに蓄積された値である6を返す。

2つめにproduct関数を定義する。
product関数とは、`product([n1,n2,n3,...]) = n1*n2*n3`のように配列の要素の積を計算する関数。
reduce関数を利用するとかきのようになる。

```javascript
var product = (array) => {
 return array.reduce((accumulator, item) => {
  return accumulator * item;
 }, 1)
}
```

sum関数やproduct関数では配列を処理して1つの値に集約させていた。
ところが、reduceメソッドに渡す引数をうまく設定すれば配列を別の配列に変換できる。

このような関数を**map関数**と呼ぶ。
mapとはあるデータの集合を一定の手順に従って別のデータの集合に変換する作業。

簡単な例では奇数の集合を偶数の集合に変換する処理。
`succ(x) = x +1`

```javascript
var map = (transform) => {
 return (array) => {
  return array.reduce((accumulator, item) => {
  return accumulator.concat(transform(item));
  },[]) // 初期値として空の配列を設定する
 }
}
```

> ![TIP]
> map 関数は2つの引数（変換関数と配列）を必要としますが、直接2つの引数を取る代わりに：
> まず1つの引数（変換関数 succ）を取り、新しい関数を返します。
> その返された関数が次の引数（配列 [1, 3, 5]）を取ります。
>
> つまり、map(succ)([1, 3, 5]) は以下のように解釈できます：
>
> map が succ を引数として受け取り、新しい関数を返す。
> その新しい関数が [1, 3, 5] を引数として受け取り、最終的な結果を生成する。

このようにメソッドに渡す引数を変えるだけで様々な関数を作れるのはreduceメソッドが汎用的な部品となっているから。

汎用性・再利用性が高いことによるメリット

- バグの予防
  - 汎用性が高い部品を組み合わせればコード量が減り、バグも減る。
- メンテナンス性の向上
  - 同じ部品を再利用していれば修正は1箇所で済む。
- 複雑性の制御
  - プログラム全体の見通しを良くして複雑性に対抗する。

## 部品を組み合わせる

モジュール化に必要な代三の性質は部品が合成できること。

### 関数適用で部品を組み合わせる

小さな部品を組み合わせてlength関数を作成する。

まず、ある値を引数に渡すと値を返す関数を作る。
constant関数をconstant(1)のように部分適用すると必ず1を返す関数が得られる。

```javascript
var constant = (any) => {
 return (_) => {
  return any;
 };
};

var alwaysOne = constant(1);
```

このalwaysOne関数をmap関数に渡すと配列の全要素を1に置き換える関数が得られる。

```javascript
expect(
 map(alwaysOne)([1,2,3])
).to.eql(
 [1,1,1]
);
```

この配列を全て合計すると3が得られる。
map(alwaysOne)(array)を適用させるとlength関数ができる。

```javascript
var length = (array) => {
 return sum(map(alwaysOne)(array));
};
```

### 関数合成による処理の合成

関数適用のモジュール化を高めるテクニックとして関数合成という手法がある。

Yを上下に反転してλ 左右に反転して人にする処理。

この本では関数を受け取り関数を返す関数をcompose関数と呼ぶ。

```javascript
var compose = (f,g) => {
 return (arg) => {
  f(g(arg));
 };
};
```

compose関数による関数合成を用いるとlength関数はより簡潔に定義することができる。

```javascript
// sumは自前で定義
// 基本的な関数
const compose = (f, g) => x => f(g(x));
const map = f => arr => arr.map(f);
const sum = arr => arr.reduce((a, b) => a + b, 0);
const alwaysOne = (_) => 1;

// length 関数の定義
const length = compose(sum, map(alwaysOne));

// 使用例
const array = [1, 2, 3, 4, 5];
console.log(length(array)); // 出力: 5

// 引数を明示した書き方
var length = (array) => {
 return compose(sum, map(alwaysOne));
}
```

このlengthは処理の対象となる引数が見当たらない。
このように引数を省略して関数を定義する手法を
**ポイントフリースタイル**と呼ぶ。
この手法は表現が簡潔になるが処理の対象が不明瞭になるという欠点がある。

### 関数による遅延評価

遅延評価という手法により関数のモジュール性は更に高くなる。
**遅延評価**とはコードの計算が後回しにされる評価の方法。

```javascript
length([1, 1 + 1])
// output 2

// 配列の第二要素を無名関数にする。
length([1, (_) => {
 return 1 + 1;
}])
// output 2
```

`(_) => { return 1 + 1; }`は評価(計算)されずに関数として1という値を返す。

この仕組みを使ってストリームを実装する。
**ストリーム**とは値の並びの一部を遅延評価によって実現したデータ構造のこと。

ストリームは配列と似ているが2番目以降の要素が通常の配列と異なる。
後尾を無名関数で実現する。

```javascript
// ストリームの例
var aStream = [1, (_) => {
 return 2;
}]
```

ストリームの先頭要素を取り出すにはaStream[0]とする。
ストリームの後尾を取り出すにはaStream[1]()とする。

ストリーム型の際立った点は再帰処理と組み合わせると無限に続くデータを表現できる。

```javascript
var enumFrom = (n) => {
 return [n, (_) => {
  return enumFrom(succ(n));
 }];
};
```

enumFrom(n)としたストリームは無名関数が永遠に入れ子になった構造になる。
上記を元にして無限の偶数列を作成する。

```javascript
var even From = (n) => {
 return [n, (_) => {
  return evenFrom(n + 2);
 }]
};
var evenStream = evenFrom(2);
```

このようなストリームを毎回作るのではなく、あらかじめ汎用的な関数を定義しておき、
その関数を再利用するほうが便利。

```javascript
var iterate = (init) => {
 return(step) => {
  return [init, (_) => {
   return iterate(step(init))(step);
  }];
 };
}
```

---
claude_ai
この関数の使い方を教えてください。

この iterate 関数は、初期値と次の値を生成するステップ関数を使って無限シーケンスを生成するための高階関数です。以下にその使い方と動作の説明を示します：

基本的な使い方:
`const naturals = iterate(0)(n => n + 1);`
この例では、0から始まる自然数の無限シーケンスを生成します。

値の取得:

```javascript
console.log(naturals[0]); // 0 (初期値)
console.log(naturals[1]()); // [1, Function] (次の要素)
console.log(naturals[1]()[0]); // 1 (次の要素の値)
console.log(naturals[1]()[1]()); // [2, Function] (その次の要素)
```

より複雑な例:

```javascript
// 2の累乗の無限シーケンス
const powers_of_two = iterate(1)(n => n * 2);

console.log(powers_of_two[0]); // 1
console.log(powers_of_two[1]()[0]); // 2
console.log(powers_of_two[1]()[1]()[0]); // 4
console.log(powers_of_two[1]()[1]()[1]()[0]); // 8
```

ヘルパー関数の作成:
シーケンスの操作を簡単にするために、以下のようなヘルパー関数を作成すると便利です：

```javascript
const head = seq => seq[0];
const tail = seq => seq[1]();
const take = (n, seq) => {
    if (n <= 0) return [];
    return [head(seq), ...take(n - 1, tail(seq))];
};

// 使用例
const fib = iterate([0, 1])(([a, b]) => [b, a + b]);
console.log(take(10, fib)); // [[0,1], [1,1], [1,2], [2,3], [3,5], [5,8], [8,13], [13,21], [21,34], [34,55]]
```

この iterate 関数の主な特徴は：

遅延評価：値は必要になるまで計算されません。
無限シーケンス：理論的には無限に続くシーケンスを表現できます。
柔軟性：初期値とステップ関数を変更することで、様々なシーケンスを生成できます。
この関数は関数型プログラミングの概念を活用しており、特に無限データ構造や遅延評価を扱う場合に有用です。ただし、使用する際は無限ループに陥らないよう注意が必要です。

iterate 関数は2つの引数 init と step を受け取りますが、カリー化されているため、これらの引数は別々に渡します。以下にそれぞれの引数の説明と例を示します：

init (初期値):

これはシーケンスの最初の値です。
どんな型の値でも渡すことができます（数値、文字列、配列、オブジェクトなど）。

step (ステップ関数):

これは現在の値を受け取り、次の値を返す関数です。
1つの引数を取り、新しい値を返す関数である必要があります。

使用例：

自然数のシーケンス:

```javascript
const naturals = iterate(0)(n => n + 1);
```

ここで、

init は 0 （最初の自然数）
step は n => n + 1 （現在の数に1を加える関数）

2の累乗のシーケンス:

```javascript
const powersOfTwo = iterate(1)(n => n * 2);
```

ここで、

init は 1 （2の0乗）
step は n => n * 2 （現在の数を2倍にする関数）

フィボナッチ数列:

```javascript
const fibonacci = iterate([0, 1])(([a, b]) => [b, a + b]);
```

ここで、

init は [0, 1] （最初の2つのフィボナッチ数）
step は ([a, b]) => [b, a + b] （現在の2つの数から次の2つの数を計算する関数）

文字列の繰り返し:

```javascript
const repeatingString = iterate("A")(s => s + "A");
```

ここで、

init は "A" （最初の文字列）
step は s => s + "A" （現在の文字列に"A"を追加する関数）

これらの例から分かるように、init と step は扱うデータの性質に応じて柔軟に設定できます。重要なのは、step 関数が常に同じ型の値を返すことです（例えば、数値から始まったら常に数値を返す、配列から始まったら常に配列を返すなど）。これにより、一貫したシーケンスが生成されます

---

このITERATE関数を再利用してiterate(n)(succ)とすれば、
先程定義したenumFrom関数になる。

```javascript
// 元のやつ
// var enumFrom = (n) => {
//  return [n, (_) => {
//   return enumFrom(succ(n));
//  }];
// };
var enumFrom = (n) => {
 return iterate(n)(succ);
};
// 自然数列を定義する
var naturals = enumFrom(1);

// 偶数列を定義する
var twoStep = (n) => {
 return n + 2;
};

var evenStream = iterate(2)(twoStep)

```

---
カリー化とは、最初に渡した引数で関数が処理した値を、次の引数に代入した関数に処理させることですか？

カリー化（currying）の概念について、少し誤解があるようですので、正確に説明させていただきます：

カリー化とは、複数の引数を取る関数を、それぞれ単一の引数を取る一連の関数に変換する技法です。カリー化された関数は、引数を1つずつ受け取り、最後の引数が渡されるまで新しい関数を返し続けます。

カリー化の主な特徴：

引数の分離： 複数の引数を別々に渡すことができます。
部分適用： 一部の引数だけを適用し、残りの引数を後で適用することができます。
関数の合成： 単一引数の関数は合成しやすいため、より柔軟なプログラミングが可能になります。
カリー化は、「最初に渡した引数で関数が処理した値を、次の引数に代入する」というものではありません。むしろ、各引数は独立して扱われ、最終的にすべての引数が揃ったときに元の関数の処理が実行されます。

例えば：

javascript

Copy
// 通常の関数
function add(a, b) {
  return a + b;
}

// カリー化された関数
function curriedAdd(a) {
  return function(b) {
    return a + b;
  }
}

// 使用例
console.log(add(2, 3));        // 5
console.log(curriedAdd(2)(3)); // 5

// 部分適用の例
const addTwo = curriedAdd(2);
console.log(addTwo(3));        // 5
console.log(addTwo(4));        // 6
この例では、curriedAdd は最初の引数 a を受け取り、次の引数 b を待つ新しい関数を返します。両方の引数が揃ったときに初めて加算が行われます。

カリー化は関数型プログラミングにおいて重要な概念で、コードの再利用性と柔軟性を高めるのに役立ちます。

---

生成されたストリームを加工し、目的のストリームを得るという方法も考えられる。

以下のfilter関数は条件に合致した要素だけをストリームに残す関数。

```javascript
var filter = (predicate) =>　{ // predicate 述語
 return (aStream) => {
  var head = aStream[0];
 　// 先頭要素が条件に一致
  if(predicate(head) === true) {
   return [head, (_) => {
    return filter(predicate)(aStream[1]());
   }];
  } else {
   return filter(predicate)(aStream[1]());
  }
 }
}
```

このfilter関数を用いて1行目から3行目で偶数かどうか判定するeven関数を作ることができる。

```javascript
var even = (n) => {
 return (n % 2) === 0;
};
var evenStream = filter(even)(enumFrom(1));
```

---
処理の流れは以下のようになります：

filter 関数が even を引数として受け取り、新しい関数を返す。
その新しい関数が enumFrom(1) を引数として受け取る。
結果として、1から始まる整数のストリームから偶数のみをフィルタリングしたストリームが生成される。

この構造はカリー化の一例で、filter 関数が部分適用されています。even 関数自体は個々の数値に対して適用され、ストリームの各要素をフィルタリングするために使用されます.

---

今までに定義した関数の動作を確認するため、elemAt関数を定義する。

ストリームのn番目の要素を返す。

```javascript
var elemAt = (n) => {
 return (aStream) => {
  if (n === 1) {
   return aStream[0];
  } else {
   return elemAt(n-1)(aStream[1]());
  };
 };
};

// 3番目の要素を求める方法
elemAt(3)(evenStream);

// 6
```

このelemAt関数は何番目の要素であってもその要素を返す。　つまり渡されるデータの長さを気にすることなく利用できる。
これが遅延評価の優れた点。

---
これはどういう意味ですか？
例えば15に引数を設定した場合、15まで処理を必要な文行うということですか？Editはい、その理解は正確です。遅延評価の優れた点を説明しましょう：

オンデマンド計算：
elemAt(15)(evenStream) を呼び出した場合、関数は15番目の偶数を見つけるまでのみ計算を行います。つまり、1から30までの整数を生成し、そこから15個の偶数を選び出します。
無限のデータ構造：
evenStream は理論的には無限の偶数列です。しかし、遅延評価のおかげで、実際に必要な部分だけが計算されます。
メモリ効率：
すべての偶数を前もって計算して保存する必要がないため、メモリ使用量が抑えられます。
柔軟性：
データの長さを事前に知る必要がありません。15番目の要素も、1000000番目の要素も、同じ関数で取得できます。
パフォーマンス：
必要な計算のみを行うため、大規模なデータセットでも効率的に動作します。

例として、elemAt(15)(evenStream) の処理を段階的に見てみましょう：

evenStream から最初の偶数(2)を取得
次の偶数(4)を取得
この処理を15回繰り返す
15番目の偶数(30)に到達したら、その値を返して停止

重要なのは、16番目以降の偶数は全く計算されないことです。これが「必要な分だけ行う」という遅延評価の本質です。
この方法は、無限のデータストリームや非常に大きなデータセットを扱う際に特に有用です。必要な部分だけを計算するため、理論上は無限のデータ構造でも実用的に扱えるのです

---

一方で配列などの有限の長さを持つデータの場合はこうはいかない。

```javascript
var elemAt = (n) => {
 return (aStream) => {
  if (n === 1) {
   return aStream[0];
  } else {
    var tail = anArray.slice(1, anArray.length);
    return elemAt(n-1)(tail);
  };
 };
};
```

この関数を用いて4番目の数値を求めるとUndefineが返る。
これは数値が返る場合とundefineが返る場合を想定しないといけないので関数の組み合わせが複雑になる。

このように遅延評価ではデータを処理する側はデータの長さを気にする必要がない。
つまりデータを作成するモジュールとデータを処理するモジュールの独立性が高まり、両者を簡単につなぎ合わせることが可能になる。

## テストが容易である

モジュール化によってコードの独立性が高まると単体テストが容易になる。
参照透過性のあるコードは依存関係が明確なのでテストを何度繰り返しても結果は不変だから。

この本ではexpect.jsというテスト用ライブラリを使ってテストを記述する。

```javascript
expect(
  succ(1)
).to.eql(
  2
);
```

コードに参照透過性がなければコードのテストは不可能か煩雑になる。
例えば対戦ゲームの勝者を判定してその結果を端末に表示するコードを考えてみる。
このコードは画面出力という副作用を伴うので自動テストで挙動を確認することはできない。

```javascript
var winner = (playerL, playerR) => {
  if (playerR.score > playerL.score) {
    console.log(playerR.name + "が勝者です。")
  } else if (playerR.score < playerL.score) {
    console.log(playerL.name + "が勝者です。")
  } else {
    console.log("引き分けです。");
  }
}
```

この問題に対処する方法は副作用のある部分と純粋な関数を分離すること。
winner関数とjudge関数とannounce関数、そして副作用を伴うdisplayWinner関数に分離する。

```javascript
var judge = (playerL, playerR) => {
  if (playerR.score > playerL.score) {
    return playerL;
  } else if (playerR.score < playerL.score) {
    return playerR;
  } else {
    return null;
  }
};

// 勝者を告げる文字列を生成
var announce = (winner) => {
  if (winner) {
    return winner.name + "が勝者です。";
  } else {
    return "引き分けです。";
  }
};

// 勝者を表示する
var displayWinner = (winner) => {
  console.log(announced(winner));
};
```

winner関数という副作用を持つ関数が、announce関数、judge関数、displayWinner関数の3個の関数に分割される。
この図で白抜きされているボックスは純粋な関数であり、黒塗りされているボックスは副作用を持つ関数。

このように副作用を分離すればjudge関数とannounce関数についてはテストで挙動を確認できるようになる。

```javascript
var socrates = {
  name: "ソクラテス",
  score: 10
};
var plato = {
  name: "プラトン",
  score: 20
};

// 純粋な関数テストをする
expect(
  announce(judge(socrates, plato))
).to.eql(
  "プラトンが勝者です。"
);

```

## コードの正しさを証明できる

参照透過性はコードに数学的な性質という恩恵をもたらしてコードの推論を可能にする。
**推論**とはある式を元にしてそれと等しい式を導く作業。

コードの推論を可能にするにはコードを等式として扱えなければならない。

参照透過性があるコードはどんなxに対しても x === x とならなければならない。

## 証明で正しさを検証する

仮に命題A === Bを証明する。
式Aの意味を変えることなく式Aを変形し、式Bの意味を変えることなく式Bを変形することを試みる。

```javascript
A === 1 // ルール1
B === 1 // ルール2
```

命題A === B の両辺にそれぞれ上記のルールを適用するといずれも1となり、両辺は等しくなる。

map(succ)([1, 2, 3])と[2, 3, 4]も、見た目は全く違いますが、結果は同じ。

下記は実際的な例題。

```javascript
succ(x) = x +1
succ(0) + succ(x) === succ(succ(x))
```

```javascript
succ(0)+succ(x) === succ(succ(x))

(0+1)+succ(x) succ(x+1)

(0+1) + (x+1) (x+1)+1

1+(x+1) === 1+(x+1)
```

関数定義を証明の前提に使えるのは参照透過性のあるコードに数学の等式としての性質があるため。

```javascript
// Nは変数を意味する
succ(N) === N +1
```

この項で紹介されたのは等式推論と呼ばれる単純な証明法。
再帰的な構造を持ったデータでは数学的帰納法という手法を用いて
コードの正しさを検証できる。

## プロパティテストで正しさを証明する

証明の作成は複雑なケースや多数のルールが存在する場合、人間の直感が不可欠になる。
単体テストの場合は全てのテストケースが必要となる。

これらのバランスをとる方法としてプロパティテストと呼ばれるテスト手法がある。

プロパティテストででは大量のテストケースを作成し、コードが一定の性質を保っているかを確認する。
(性質≒仕様)

純粋な関数はそれぞれの関数を独立にテストできるのでプロパティテストに適している。
これまでの関数に加えていくつかの関数を追加するだけで原始的なプロパティテストは簡単に実装可能。

```javascript
// ストリームのmap関数
var map = (transform) => {
  return (aStream) => {
    var head = aStream[0];
    return [transform(head), (_) => {
      return map(transform)(aStream[1]());
    }];
  };
};
// ストリームの先頭から引数n分だけ取り出すtake関数
var take = (n) => {
  return (aStream) => {
    if (n === 0) {
      return null;
    } else {
      return { aStream[0] , (_) => {
        return take(n-1)(aStream[1]());
      }};
    }
  }
}
// ストリームの全ての要素がtrueであるか判定するall関数
var all = (aStream) => {
 var allHelper = (aStream, accumulator) => {
   var head = aStream[0];
   var newAccumulator = accumulator && head;
   if (aStream[1]() === null) {
     return newAccumulator;
   } else {
     return allHelper(aStream[1](), newAccumulator);
   }
 };
 return allHelper(aStream, true);
};

// 検証の対象となる命題
var proposition = (n) => {
 return succ(0) + succ(n) === succ(succ(n));
};
```

---

このコードは関数型プログラミングの概念を使用して、ストリーム（遅延リスト）を操作し、数学的命題を検証するためのものです。実際の使い方を示すために、以下のような例を挙げることができます：

まず、succ関数を定義します（これは与えられたコードには含まれていないので、追加する必要があります）：

javascriptCopyconst succ = n => n + 1;

自然数のストリームを生成する関数を作成します：

javascriptCopyconst naturals = (start = 0) => [start, () => naturals(start + 1)];

これらの関数を使って命題を検証します：

javascriptCopy// 最初の100個の自然数に対して命題を検証
const propositionStream = map(proposition)(naturals());
const first100 = take(100)(propositionStream);
const result = all(first100);

console.log("命題は最初の100個の自然数に対して成り立つか：", result);

より具体的な例を見てみましょう：

javascriptCopy// ストリームの最初の5つの要素を表示する関数
const printFirst5 = (stream) => {
  let current = stream;
  for (let i = 0; i < 5; i++) {
    console.log(current[0]);
    current = current[1]();
  }
};

console.log("自然数ストリームの最初の5要素：");
printFirst5(naturals());

console.log("命題を適用した結果の最初の5要素：");
printFirst5(map(proposition)(naturals()));

// 特定の値に対して命題を検証
console.log("n = 5 の場合の命題の結果：", proposition(5));
このコードを実行すると、以下のような出力が得られるはずです：
Copy命題は最初の100個の自然数に対して成り立つか： true

自然数ストリームの最初の5要素：
0
1
2
3
4

命題を適用した結果の最初の5要素：
true
true
true
true
true

n = 5 の場合の命題の結果： true
このコードは以下のことを示しています：

ストリームを使用して無限の数列（この場合は自然数）を表現できる
map関数を使用してストリームの各要素に関数を適用できる
take関数を使用してストリームの一部を取り出せる
all関数を使用してストリームの全ての要素が条件を満たすかを確認できる
これらの関数を組み合わせて、数学的命題を効率的に検証できる

このアプローチは、無限の入力に対して命題を検証する必要がある場合や、大量のデータを効率的に処理する必要がある場合に特に有用です。

---

全てを検証は不可能。
なので100個だけ取り出してall関数で全ての要素がtrueになるか調べる。

```javascript
/* 100個の整数について命題が正しいかをテストする */
expect(
 all(
   take(100)(
     map(proposition)(enumFrom(0))
   )
 )
).to.eql(
 true
);
```

- プロパティベーステストはテストケースが満たすべき条件を定義する
- 例：`succ`関数の引数は必ず0以上の整数である

ScalaCheckによる実装例

```scala
property("succ") = forAll((x: Int) =>
  (x >= 0) ==> (succ(0) + succ(x) == succ(succ(x)))
)
```

(x >= 0) ==>：事前条件の設定
ScalaCheckは100回のテストケースを自動生成
ランダム生成により網羅的な検証が可能

関数型プログラミングは数学との親和性が高く、証明という強力な検証を可能にする。

**プログラミング言語は100年も歴史が無いが、数学は2000年以上に渡って蓄積した偉大な知的財産**である。

# 第二部 JavaScriptによる関数型プログラミングの実践

## DRYの原則

DRYの原則 = Don't Repeat Yourself.
同じことを繰り返すな。

P.117 省略

## 抽象化への指向

抽象化とは「物事の本質を抽出して些末な詳細を隠す」という意味。
犬という動物に「犬」という一般的な名前をつけるのもその一種。
-> わざわざ四本足、鳴き声などを呼称しない。

数も抽象化。
ウサギの重さや長さを測らずに5羽などの数で数える。

関数も抽象化の一種。

`var succ = (x) => x +1;`

上記の関数を呼び出す時にsucc(1)のように関数内部が隠れているから。

下記は抽象度が低い実装の例。

合計を計算するのに1つずつ要素を足し合わせている。

```javascript
var anArray = [2,3,5,7];
var sum = (array) => {
  var result = 0;
  for(var index = 0; index < array.length; index++) {
  result = result + array[index];
  }
  return result;
};
sum(anArray);
```

抽象化を一歩進める。
繰り返し処理が隠蔽されているが、resultは残ったまま。

```javascript
var sum = (array) => {
  var result = 0;
  array.forEach((item) => {
    result = result + item;
  });
  return result;
};
```

reduce関数を使うとさらに反復処理を抽象化できる。

resuceメソッドは第一引数に関数を 第二引数に値を取ることができる。
第一引数の関数はコールバック関数と呼ばれ、この引数もまた2つの引数を取る。

コールバック関数の引数:

第1引数: 直前のコールバック関数の返値
2.第2引数: 配列の各要素（順番に）

先頭要素の処理:
第1引数: reduceメソッドの第2引数（初期値）

```javascript
var sum = (array) => {
  return array.reduce((x, y) => {
    return x + y;
  });
};
```

抽象化によってコードを簡潔に記述するのは、人は複雑なことを把握するのが苦手だから。
抽象化は複雑性に対処するツールになる。

## セマンティクスを意識する

抽象化の目的は細部を隠匿すること。
このような抽象化はプログラミング言語の処理系そのものにも施されている。
処理系で隠された詳細とはセマンティクス(意味論)と呼ばれる領域。

処理系はコードを実行してその結果を計算する。
処理の対象となるコードは単なるアルファベットと記号。
これをシンタックスまたは「構文」と呼ぶ。

この項は普段目に見えない領域を目に見える形にする。

省略

P.128

## テストに親しむ

テストを書くことで抽象化したコードも使いこなせるようになる。
テストには単体テスト、機能テスト、結合テストがある。
この中で単体テストが汎用化に近づかせられる。

### 単体テストの仕組み

テストの実行にはテストフレームワークを使用するのが一般的。
この本では「Mocha」というテストフレームワークを使用している。

**単体テスト**とは、ひとつひとつの関数の挙動を確かめるテスト。
テストではテスト対象の関数を実行してコンピューターの計算と期待する値を比較する。

テストする値はアサート asser(表明)関数で比較する。
アサートとは「必ずこうあるべきである」と計算機に主張する行為。
Mochaにアサート機能はないので外部ライブラリを利用する。

```javascript
// assert ライブラリを使う場合
var assert = require("assert");
assert.equal(1 + 2, 3);

// expect.jsライブラリを使う場合
var expect = required("expext.js");
expect(
  1 + 2
).to.eql(
  3
);
```

### テストの意義

単体テストはテストがアプリケーションの至る所に張り巡らされたときに真価を発揮する。

抽象化の手法でコードの複雑性を隠匿しても組み合わせによる依存関係の複雑化を食い止めることはできない。
十分な単体テストで個々のコードの挙動を確認できていれば、穴は防げる。

あらゆる関数から参照されている関数があったとして、その一つの関数の変更が及ぼす影響は予測ができない。

しかしテストを実行すればその影響範囲を推し量ることができる。

> [!INFORMATION]
> 本書のテストコード
> <https://akimichi.github.io/functionaljs/>

### JavaScriptと関数型プログラミング

本書でJavaScriptを採用したのは知名度。
ただ、関数型言語にない機能がある。

1. 可変なデータ構造を許容する。
2. 動的型付け言語である。
3. シングルスレッドで動作する言語である。

1についてはデータの更新を禁止する。 constを使う。
2については型の情報をコメントする。 TypeScriptを使う。
3についてはこの本では割愛。

ただ、このデメリットを差し引いても関数型言語の表現力はすごい。