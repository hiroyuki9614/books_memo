# 関数型プログラミングの基礎

## 1 章

読んだけど省略

## 2 章

### なぜ関数型プログラミングが重要か

**数学の関数は「ある値に対して、ただ一つの値が対応するような関係」**
関数は 1 つの入力に対して 1 つの出力。
自販機に例えられる。 引数・入力(硬貨)と出力・戻り値（飲み物）

**入力が同じならいつどこで呼び出されても値は一定**
三角関数の cos(θ)はいつどこで呼び出しても値は 1
入力 0 に対しての出力はいつも 1

**プログラミングが数学的な関数と異なる点**
・計算を具体的な「手順」として定義しなければならない。
手順とは計算が完了するための有限のステップ。　
このような制限を設けた手順のことをアルゴリズムと呼ぶ。
・関数によっては同じ因数に対していつも同じ結果を返すわけではない。
例えば現在の時刻を求める関数は呼び出されるたびに
前回とは異なる結果を返す。

### 関数型プログラミングの特徴

関数型モデルを実装したプログラミング言語を関数型言語という。
JavaScript は関数型言語と命令形言語の機能を持つ。

これらの条件を満たせば関数型プログラミングは可能。

**関数を言語の最も基本的な要素として扱う**
関数に値としての地位を与えることで関数に関数を渡したり、
関数から返すことが可能になる。
**参照透過性を確保できること**

> [!NOTE]
> 参照透過性とは、プログラムの構成要素が同じであれば同じ結果を返す性質を指す。

## ファーストクラスオブジェクトとしての関数

関数型プログラミングを可能にする第一の性質は
**ファーストクラスオブジェクト(first-class citizen)** としての関数。
ファーストクラスオブジェクトとは計算の対象となる「値」を意味する。
ファーストクラスオブジェクトとしての値は次のように変数にバインドしたり、データ構造に埋め込んだり関数に渡したり、関数の返値とすることが可能である。

```bash
> var zero = 0; # 変数に値をバインド
undefined
> var birthday = { # データ構造に値を埋め込む
... year: 1999,
... month: 1,
... day: 12
... }
undefined
> Math.sqrt(2) # 関数に値を渡す
1.4142135623730951 # 関数から値を返す
```

関数がファーストクラスオブジェクトであるということは、関数も次のような操作が可能。

1. 関数を変数にバインドする
2. 関数をデータ構造に埋め込む
3. 関数適用の際に関数を引数として渡す
4. 関数から関数を返す。

### 関数は変数にバインドすることができる。
元々関数定義(λ式 :ラムダ式)そのものには名前はない。 -> 無名関数

ラムダ式として変数にバインドすることで無名関数に名前をつける。

```javascript
var succ = (n) => { // var succ = 以降がラムダ式
	return n+ 1;
}
```
### 関数はデータ構造に埋め込むことが埋め込むことができる

関数はデータ構造に埋め込むことができる

複数の関数を同じオブジェクトで埋め込むことによって似通った機能を持つ関数を一箇所にまとめることができる。

```javascript
var math =
add: (n, m) => {
	return n + m;
};
```
関数がファーストクラスオブジェクトであることの最大の利点は**高階関数**の利用が可能になること。
**高階関数(higher-order function)** とは関数を引数として受け取ったり関数を返すことができる関数。
高階関数ではある関数の引数に別の関数を渡すことができる。　この手法を「**関数渡し**」と呼ぶ。

下記はforEachメソッド。
関数を受け取り配列の要素ごとにその渡された関数を実行する高階関数。

```javascript
var sum = (array) => {
	var result = 0;
	array.forEach((item) => {
		result += item;
	})
	return result;
}
```
forEachのメソッドの引数は(item) => { ... } という関数になっている。
この部分が関数渡し。
この関数が呼び出される時にitemに個々の要素が入る。
arrayが[1,3,5]の場合、 0 + 1, 1 + 3, 4 + 5が計算される。

高階関数は関数を返すこともできる。この一例として**カリー化**がある。
下記は足し算を定義するadder関数をカリー化により定義したもの。

```javascript
var adder = (n) => {
	return (m) => { return n + m; }; // 無名関数を返す
};
```
これはnというただ一つの引数を受け取ると`(m) => { return n + m; };`という無名関数を返す。
adder(1) だと`(m) => { return n + m; };`が返ってくる。 adder(1)(2)だと無名関数に2が渡されて3が返る。
カリー化関数は関数が関数を返すという性質により成り立つ。

## 参照透過性
関数型プログラミングに必要な第二の性質は参照透過性。 参照透過性とは、簡単に言うと「プログラミングの構成要素が同じもの同士は等しい」という性質。
`A === A`

プログラミングでは必ずしも参照透過性が担保されているとは限らない。

### 値の参照透過性

`2 === 2`は必ず真になる。
```javascript
> 2 === 2
true
```
javascriptの数値にはいつも参照透過性が保たれているが、配列やオブジェクトなどの合成型は参照透過性を持たない。

### 変数の参照透過性
`x === x`にも参照透過性が成立しているか。

```javascript
> var x = 1
undefined
> x === x;
true
```
`x === x`の等式が成立していることから参照透過性が成立している。
が、変数の参照透過性もあらゆる場面で保証されているわけではない。
代入という操作が加わると変数の参照透過性は破壊される。

### 関数の参照透過性

関数が参照透過性を持つためのルールはある関数への引数が同じであればその関数は必ず同じ値を返さなければならない。

1を渡すと必ず2を返すsucc関数があるとする。
```javascript
> succ(1) === succ(1)
> true
```

ただしあらゆる関数が参照透過性を保証されているわけではなく、ある種の関数には参照透過性がない。(副作用)

### 参照透過性を破壊するもの

値の中には一旦作成されたあとに内容が変更されるデータ構造がある。
内容が変更される可能性のあるデータは**可変データ**と呼ばれる。
このようなデータに参照透過性はない。

JavaScriptの配列は可変なデータ構造の一つ。

```JavaScript
> var array = [1]
undefined
> array
[ 1 ]
> array.push(2)
2
> array
[ 1, 2 ]
```

この例では配列の値を2回確かめているが結果がそれぞれ異なる。
pushのようにデータの中身を変更するメソッドを**破壊的メソッド**と呼ぶ。

#### 代入は参照透過性を破壊する
変数の参照透過性は代入という操作で簡単に破壊される。
「代入」とは変数に何らかの値を割り当てる操作。
`var x = 0; // この操作が代入`