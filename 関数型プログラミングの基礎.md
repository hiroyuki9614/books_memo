# 関数型プログラミングの基礎

## 1 章

読んだけど省略

## 2 章

### なぜ関数型プログラミングが重要か

**数学の関数は「ある値に対して、ただ一つの値が対応するような関係」**
関数は 1 つの入力に対して 1 つの出力。
自販機に例えられる。 引数・入力(硬貨)と出力・戻り値（飲み物）

**入力が同じならいつどこで呼び出されても値は一定**
三角関数の cos(θ)はいつどこで呼び出しても値は 1
入力 0 に対しての出力はいつも 1

**プログラミングが数学的な関数と異なる点**
・計算を具体的な「手順」として定義しなければならない。
手順とは計算が完了するための有限のステップ。　
このような制限を設けた手順のことをアルゴリズムと呼ぶ。
・関数によっては同じ因数に対していつも同じ結果を返すわけではない。
例えば現在の時刻を求める関数は呼び出されるたびに
前回とは異なる結果を返す。

### 関数型プログラミングの特徴

関数型モデルを実装したプログラミング言語を関数型言語という。
JavaScript は関数型言語と命令形言語の機能を持つ。

これらの条件を満たせば関数型プログラミングは可能。

**関数を言語の最も基本的な要素として扱う**
関数に値としての地位を与えることで関数に関数を渡したり、
関数から返すことが可能になる。
**参照透過性を確保できること**

> [!NOTE]
> 参照透過性とは、プログラムの構成要素が同じであれば同じ結果を返す性質を指す。

## ファーストクラスオブジェクトとしての関数

関数型プログラミングを可能にする第一の性質は
**ファーストクラスオブジェクト(first-class citizen)** としての関数。
ファーストクラスオブジェクトとは計算の対象となる「値」を意味する。
ファーストクラスオブジェクトとしての値は次のように変数にバインドしたり、データ構造に埋め込んだり関数に渡したり、関数の返値とすることが可能である。

```bash
> var zero = 0; # 変数に値をバインド
undefined
> var birthday = { # データ構造に値を埋め込む
... year: 1999,
... month: 1,
... day: 12
... }
undefined
> Math.sqrt(2) # 関数に値を渡す
1.4142135623730951 # 関数から値を返す
```

関数がファーストクラスオブジェクトであるということは、関数も次のような操作が可能。

1. 関数を変数にバインドする
2. 関数をデータ構造に埋め込む
3. 関数適用の際に関数を引数として渡す
4. 関数から関数を返す。

### 関数は変数にバインドすることができる。
元々関数定義(λ式 :ラムダ式)そのものには名前はない。 -> 無名関数

ラムダ式として変数にバインドすることで無名関数に名前をつける。

```javascript
var succ = (n) => { // var succ = 以降がラムダ式
	return n+ 1;
}
```
### 関数はデータ構造に埋め込むことが埋め込むことができる

関数はデータ構造に埋め込むことができる

複数の関数を同じオブジェクトで埋め込むことによって似通った機能を持つ関数を一箇所にまとめることができる。

```javascript
var math =
add: (n, m) => {
	return n + m;
};
```
関数がファーストクラスオブジェクトであることの最大の利点は**高階関数**の利用が可能になること。
**高階関数(higher-order function)** とは関数を引数として受け取ったり関数を返すことができる関数。
高階関数ではある関数の引数に別の関数を渡すことができる。　この手法を「**関数渡し**」と呼ぶ。

下記はforEachメソッド。
関数を受け取り配列の要素ごとにその渡された関数を実行する高階関数。

```javascript
var sum = (array) => {
	var result = 0;
	array.forEach((item) => {
		result += item;
	})
	return result;
}
```
forEachのメソッドの引数は(item) => { ... } という関数になっている。
この部分が関数渡し。
この関数が呼び出される時にitemに個々の要素が入る。
arrayが[1,3,5]の場合、 0 + 1, 1 + 3, 4 + 5が計算される。

高階関数は関数を返すこともできる。この一例として**カリー化**がある。
下記は足し算を定義するadder関数をカリー化により定義したもの。

```javascript
var adder = (n) => {
	return (m) => { return n + m; }; // 無名関数を返す
};
```
これはnというただ一つの引数を受け取ると`(m) => { return n + m; };`という無名関数を返す。
adder(1) だと`(m) => { return n + m; };`が返ってくる。 adder(1)(2)だと無名関数に2が渡されて3が返る。
カリー化関数は関数が関数を返すという性質により成り立つ。

## 参照透過性
関数型プログラミングに必要な第二の性質は参照透過性。 参照透過性とは、簡単に言うと「プログラミングの構成要素が同じもの同士は等しい」という性質。
`A === A`

プログラミングでは必ずしも参照透過性が担保されているとは限らない。

### 値の参照透過性

`2 === 2`は必ず真になる。
```javascript
> 2 === 2
true
```
javascriptの数値にはいつも参照透過性が保たれているが、配列やオブジェクトなどの合成型は参照透過性を持たない。

### 変数の参照透過性
`x === x`にも参照透過性が成立しているか。

```javascript
> var x = 1
undefined
> x === x;
true
```
`x === x`の等式が成立していることから参照透過性が成立している。
が、変数の参照透過性もあらゆる場面で保証されているわけではない。
代入という操作が加わると変数の参照透過性は破壊される。

### 関数の参照透過性

関数が参照透過性を持つためのルールはある関数への引数が同じであればその関数は必ず同じ値を返さなければならない。

1を渡すと必ず2を返すsucc関数があるとする。
```javascript
> succ(1) === succ(1)
> true
```

ただしあらゆる関数が参照透過性を保証されているわけではなく、ある種の関数には参照透過性がない。(副作用)

### 参照透過性を破壊するもの

値の中には一旦作成されたあとに内容が変更されるデータ構造がある。
内容が変更される可能性のあるデータは**可変データ**と呼ばれる。
このようなデータに参照透過性はない。

JavaScriptの配列は可変なデータ構造の一つ。

```JavaScript
> var array = [1]
undefined
> array
[ 1 ]
> array.push(2)
2
> array
[ 1, 2 ]
```

この例では配列の値を2回確かめているが結果がそれぞれ異なる。
pushのようにデータの中身を変更するメソッドを**破壊的メソッド**と呼ぶ。

#### 代入は参照透過性を破壊する
変数の参照透過性は代入という操作で簡単に破壊される。
「代入」とは変数に何らかの値を割り当てる操作。
`var x = 0; // この操作が代入`

変数の参照透過性は代入という操作で簡単に破壊される。

コードの隠れた存在をコードにとってのコンテキストと呼ぶ。

> ![NOTE]
> コンテキストは日本語で「文脈」を指す。
> 例えば8月は暑いという文章にも隠れた状態が潜んでおり、
> それは場所というコンテキストである。
> 南半球の8月は真冬　文章だけでは正しさは判断できない。

代入は参照透過性の喪失という厄介な効果をもたらし、関数型プログラミングを困難にする。
その代入という仕組みを多くの言語が準備しているかというと、whileなどの反復文を利用するのに不可欠だから。

階乗は下記のようにwhile文で表す。

```javascript
var factorial = (n) => {
	var result = 1; // 結果を格納する
	var times = 1; // 反復の回数を数える
	while (times < n + 1) {
		// result を代入で更新する
		result = result * times;
		// timesを代入で更新する
		times = times + 1;
	}
	return result;
}
```

#### 副作用と入出力
ある種の関数にはもともと参照透過でない関数がある。
DataメソッドやRandメソッドなど。

入出力を扱う関数にも参照透過性はない。
ここでの入出力はプログラミングの処理系へのデータの入出力を指す。
画面の出力やファイルへの書き込み処理や、キーボードによる入力やファイルからの読み出しなど。

このような副次的な機能は**副作用**と呼ぶ。

入出力は処理系にとって隠れたコンテキスト。

## 参照透過性を保証する
まとめると参照透過性は次のような場面で喪失する。

- 値の参照透過性を破壊する可変なデータ
- 変数の参照透過性を破壊する代入操作
- 関数の参照透過性を破壊する副作用

本項ではこうした状況を回避してコードの参照透過性を探る。

### 値の参照透過性を保証する(可変なデータの排除)
一度生成されたら中身が変更されないデータのことを**不変のデータ**と呼ぶ。
値の参照透過性を確保するにはすべてのデータを不変のデータとして構築すれば良い。

JavaScriptにおける可変のデータとは配列やオブジェクト型のことを指す。
このような可変なデータを不変なデータ構造として構築するには関数を用いる。

```javascript
// これは空のオブジェクトを表現する関数です。
// どんな引数（_で表現）が渡されても常にnullを返します。
var empty = (_) => {
	return null;
}
// この関数は、キーとオブジェクトを引数に取り、オブジェクトに対してキーを適用した結果を返します。
// ここでの「オブジェクト」は実際には関数として扱われています。
var get = (key, obj) => {
	return obj(key);
};
// この関数は新しい値をオブジェクトに「設定」します。具体的には：
// 新しいキー、値、既存のオブジェクトを引数に取ります。
// 新しい関数を返します。この関数は：
// 渡されたキー（key2）が設定しようとしたキー（key）と同じ場合、新しい値を返します。
// そうでない場合、元のオブジェクトから値を取得します。
var set = (key, value, obj) => {
	return (key2) => {
		if(key === key2) {
			return value;
		} else {
			return get(key2, obj);
		}
	};
};
```
```javascript
// まず、空のオブジェクトから始めます
let obj = empty;

// 値をセットします
obj = set('name', 'Alice', obj);
obj = set('age', 30, obj);

// 値を取得します
console.log(get('name', obj)); // 'Alice' を出力
console.log(get('age', obj));  // 30 を出力

// 存在しないキーにアクセスすると
console.log(get('city', obj)); // null を出力

// 値を更新します
obj = set('age', 31, obj);
console.log(get('age', obj));  // 31 を出力

// 元の 'age' の値は変更されていないことを確認
let oldObj = set('name', 'Alice', empty);
oldObj = set('age', 30, oldObj);
console.log(get('age', oldObj)); // 30 を出力
```

次に変数の参照透過性を保証する(代入の排除)
変数の参照透過性を保証するには代入を使わない。

多くの場合、代入を使わなくてもプログラミングは可能だが、反復処理はその限りではない。

```javascript
var add = (x, y) => {
	var times = 0;
	var result = x;

	while(times < y) {
		result = result + 1;
		times = times + 1;
	};
	return result;
};
```
関数型プログラミングの手法を使えば、代入無しで反復処理を実現できる。

```javascript
var add = (x, y) => {
	if(y < 1) {
		return x;
	} else {
		return add(x + 1, y - 1);
	}
};

console.log(add(3, 2));  // 出力: 5
console.log(add(0, 5));  // 出力: 5
console.log(add(10, 0)); // 出力: 10
console.log(add(1, 9));  // 出力: 10
console.log(add(-3, 7)); // 出力: 4
```
```
// 流れ
add(3, 2)　->
1回目 y<1なので 4,1を返す
2回目 y<1なので 5,0を返す
3回目 y<1じゃないので 5,0を返す
出力が5になる
```
関数型プログラミングによる実装では、反復を実行するwhile文を使わずに、同じ関数を呼び出す再起処理で反復を実現しいる。
代入がないがかわりに関数が再帰的に呼び出されるたびに新しい引数を渡している。

### 値の参照透過性を保証する(副作用の分離)
副作用をなくしてしまえば問題が解決するわけではない。
というのは計算機には計算結果を表示する機能やデータを記録する装置が不可欠だから。

では、関数型プログラミングではこの副作用をどのように扱うのかというと、副作用を持つ方法と副作用を持たない部分をきちんと分離する。

副作用を持たない関数を**純粋な関数**と呼ぶ。

副作用を持つ関数は純粋な関数を呼び出せるが、逆に純粋な関数から副作用を持つ関数を呼び出してはいけない。

下記は副作用が分離されていないコード
```javascript
var age = (birthYear) => {
	// todayは現時点の日付
	var today = new Date();
	// getFullYear関数は日付データに基づいて現時点の西暦を返す
	var thisYear = today.getFullYear();
	return thisYear - birthYear;
};
```
2016年時点だと17を返すが、2017年だと18という異なる値を返す。
var today = new Date();というコンテキストに依存しており、この依存がage関数から分離されていない。

内部に副作用を持つ関数は関数自体が参照透過性を失ってしまう。

age関数に参照透過性を持たせるには現在の時刻というコンテキストを外部に出す必要がある。
```javascript
var age = (birthYear, thisYear) => {
	return thisYear - birthYear;
};
```
上記のコードでは隠れていたコンテキストを関数の引数として明示的に渡すことで参照透過性を取り戻している。
そのため、age(1999, 2016)というコードはいつに時代になっても必ず17を返すことになる。
現時点での年齢を求めたい場合には、age(1999,(new Date()).getFullYear())とする。

副作用を分離するためのより柔軟な方法はモナド。
モナドは高階関数を使ってコンテキストをカプセル化する。

特に副作用の根源である入出力をカプレス化すると、副作用を持つ関数を組み合わせてより複雑な入出力を作り上げることが可能になる。

## 関数型プログラミングの利点
そもそもなんで関数型プログラミングが望ましい？
関数型プログラミングは修行僧ではなく、アスリート。

自らのコードをコントロールすることで次のような利点を手にすることができる。
- コードのモジュール性が高まる
- コードのテストを容易にする
- コードの正しさを証明できる

### 高いモジュール性
関数型プログラミングの利点として第一に挙げられるのは**モジュール性**。
ソフトウェアに色々な機能を追加するとすぐに巨大に膨れ上がる。
そうした自体に対する対処方法は全体を小さな単位に分割すること。

問題をモジュールに分解することをモジュール化と呼ぶ。

モジュール化によるプログラミングは次のような手順で問題を解決する。

1. 大きな問題を小さな問題に分割する
2. 小さな部品で小さな問題を解く
3. 小さな問題を解く小さな部品を組み合わせて大きな問題を解く

モジュール化の戦略はレゴブロックで作品を組み上げていく作業に似ている。
データ,変数,関数がブロック ブロック同士をつなぎ合わせるのは関数。

### 部品の独立性
モジュール化に必要な第一の性質はここのモジュールの機能が独立していること。
コードがモジュールとして独立していると他のコードが影響を受けにくくなる。
参照透過性はこの独立性を保証する。

### 部品の汎用性
モジュール化を成功させるためにはやみくもに独立した部品を作れば良いというわけではない。
モジュール化に必要な第二の性質は部品の汎用性。
汎用性とは「どこでも使うことができる」という性質。
レゴブロックは汎用性が高いがパズルのピースは汎用性が低い。
レゴブロックを目指す。

レゴブロックの凹凸に相当するのが引数で、関数に汎用性をもたせる一つの方法がカリー化。
カリー化により引数の個数を1個にすれば引数の数を一致させる必要がない。

関数の汎用性を高めるもう一つの方法が**関数渡し**。
関数渡しもカリー化同様、高階関数が可能にした関数型プログラミングの技法。

関数渡しの代表的な例はJavaScriptの配列に備わっているreduceメソッド。
reduceメソッドの引数を返ることで様々な関数を生み出すことができる。
forEachメソッドとreduceメソッドのsum関数を比較する。
```javascript
// forEachメソッドによるsum関数の定義
var sum = (array) => {
	var result = 0;
	var index = 0; // 反復回数を格納する
	while(index < array.length) {
		result = result + array[index];
		index = index + 1;
	}
	return result;
}

// reduceメソッドによるsum関数の定義
var sum = (array) => {
	return array.reduce(
		(accumulator, item) => {
			return accumulator + item;
		}, 0); // 代二引数に初期値として0を渡す。
};
// 配列が[1,2,3]の場合の動作
// 0 + 1 [2,3]
// 1 + 2 [3]
// 3 + 3
// 6
```
accumulator 蓄圧器の意味 アキュムレーター
reduceメソッドが起動した際、無名関数`(accumulator, item ) => { ... }`がreduceメソッドに渡される。
この関数ではaccumulatorには初期値の0、引数itemを計算し、その結果である1を次のaccumulatorとして渡す。
計算された値はaccumulatorに蓄積される。　配列に要素が無くなると、reduceメソッドはそれまでに蓄積された値である6を返す。


2つめにproduct関数を定義する。
product関数とは、`product([n1,n2,n3,...]) = n1*n2*n3`のように配列の要素の積を計算する関数。
reduce関数を利用するとかきのようになる。
```javascript
var product = (array) => {
	return array.reduce((accumulator, item) => {
		return accumulator * item;
	}, 1)
}
```